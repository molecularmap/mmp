
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Super MolecularMap ‚Äî Night Sky of Molecules</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(circle at 50% 50%, #0b1025 0%, #000010 100%);
    font-family: 'Segoe UI', system-ui, sans-serif;
    color: #e0e7ff;
  }
  header {
    position: absolute;
    top: 1rem;
    left: 1rem;
    color: #a5b4fc;
    z-index: 5;
  }
  header h1 {
    margin: 0;
    font-size: 1.6rem;
    color: #c7d2fe;
  }
  header p {
    margin: 0.2rem 0 0;
    font-size: 0.9rem;
    color: #94a3b8;
  }
  #graph {
    width: 100vw;
    height: 100vh;
  }
  .tooltip {
    position: absolute;
    background: rgba(17, 24, 39, 0.85);
    color: #f9fafb;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 0.8rem;
    pointer-events: none;
    opacity: 0;
  }
</style>
</head>
<body>
<header>
  <h1>üåå Super MolecularMap</h1>
  <p>A cosmic web of molecules ‚Äî glowing, dynamic, and interconnected.</p>
  <a href="index.html" style="color:#818cf8;text-decoration:none;">‚Üê Back to Home</a>
</header>
<div id="graph"></div>
<div class="tooltip" id="tooltip"></div>

<script>
// ======= CONFIGURATION =======
const width = window.innerWidth, height = window.innerHeight;
const nodeCount = 800;   // Number of "molecules"
const linkCount = 1800;  // Number of edges

// ======= COLOR & STYLE =======
const color = d3.scaleOrdinal()
  .domain(["disease","drug","nutrient","pathway","semantic"])
  .range(["#f87171","#38bdf8","#facc15","#4ade80","#c084fc"]);

const backgroundColor = "#030617";

// ======= CREATE RANDOM MOLECULAR NETWORK =======
const categories = ["disease","drug","nutrient","pathway","semantic"];
const nodes = d3.range(nodeCount).map(i => ({
  id: "Molecule-" + i,
  category: categories[Math.floor(Math.random() * categories.length)],
  size: Math.random() * 4 + 2
}));

const links = d3.range(linkCount).map(() => ({
  source: Math.floor(Math.random() * nodeCount),
  target: Math.floor(Math.random() * nodeCount),
  weight: Math.random()
}));

// ======= D3 SETUP =======
const svg = d3.select("#graph").append("svg")
  .attr("width", width)
  .attr("height", height)
  .style("background", backgroundColor);

const g = svg.append("g");
const tooltip = d3.select("#tooltip");

// Gradients for glowing edges
const defs = svg.append("defs");
const gradient = defs.append("linearGradient")
  .attr("id", "edgeGradient")
  .attr("x1", "0%").attr("x2", "100%")
  .attr("y1", "0%").attr("y2", "0%");
gradient.append("stop").attr("offset", "0%").attr("stop-color", "#818cf8");
gradient.append("stop").attr("offset", "100%").attr("stop-color", "#c084fc");

// ======= FORCE SIMULATION =======
const sim = d3.forceSimulation(nodes)
  .force("link", d3.forceLink(links).id(d=>d.index).distance(d=>50 + 100*d.weight))
  .force("charge", d3.forceManyBody().strength(-25))
  .force("center", d3.forceCenter(width/2, height/2))
  .force("collision", d3.forceCollide().radius(8));

const link = g.append("g")
  .selectAll("line")
  .data(links)
  .enter()
  .append("line")
  .attr("stroke", "url(#edgeGradient)")
  .attr("stroke-width", d => 0.5 + d.weight*1.2)
  .attr("stroke-opacity", 0.15);

const node = g.append("g")
  .selectAll("circle")
  .data(nodes)
  .enter()
  .append("circle")
  .attr("r", d => d.size)
  .attr("fill", d => color(d.category))
  .attr("stroke", "#ffffff")
  .attr("stroke-width", 0.3)
  .attr("filter", "url(#glow)")
  .on("mouseover", (e, d) => {
    tooltip.transition().style("opacity", 1);
    tooltip.html(`<strong>${d.id}</strong><br>Type: ${d.category}`)
      .style("left", (e.pageX + 10) + "px")
      .style("top", (e.pageY - 20) + "px");
  })
  .on("mouseout", () => tooltip.transition().style("opacity", 0))
  .on("click", (e, d) => {
    if (d.category === "disease")
      window.open(`disease.html?q=${encodeURIComponent(d.id)}`, "_blank");
    else
      window.open(`molecularmap.html?q=${encodeURIComponent(d.id)}`, "_blank");
  })
  .call(d3.drag()
    .on("start", dragStart)
    .on("drag", dragged)
    .on("end", dragEnd));

// ======= HALO PULSE ANIMATION =======
const haloLayer = g.append("g");
const clusterGroups = d3.group(nodes, d => d.category);
const halos = haloLayer.selectAll("circle")
  .data(Array.from(clusterGroups.entries()))
  .enter()
  .append("circle")
  .attr("fill", d => color(d[0]))
  .attr("opacity", 0.03)
  .attr("r", 150)
  .attr("stroke", d => color(d[0]))
  .attr("stroke-width", 1.5);

function pulse() {
  halos.transition()
    .duration(4000)
    .attr("opacity", 0.01)
    .transition()
    .duration(4000)
    .attr("opacity", 0.05)
    .on("end", pulse);
}
pulse();

// ======= SIMULATION TICK =======
sim.on("tick", () => {
  halos
    .attr("cx", d => d3.mean(d[1], n => n.x))
    .attr("cy", d => d3.mean(d[1], n => n.y))
    .attr("r", d => {
      const xs = d[1].map(n => n.x), ys = d[1].map(n => n.y);
      const dx = d3.max(xs)-d3.min(xs), dy = d3.max(ys)-d3.min(ys);
      return Math.sqrt(dx*dx + dy*dy)/2 + 100;
    });

  link
    .attr("x1", d => d.source.x)
    .attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x)
    .attr("y2", d => d.target.y);

  node
    .attr("cx", d => d.x)
    .attr("cy", d => d.y);
});

// ======= DRAG HANDLERS =======
function dragStart(e, d){
  if (!e.active) sim.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
}
function dragged(e, d){ d.fx = e.x; d.fy = e.y; }
function dragEnd(e, d){
  if (!e.active) sim.alphaTarget(0);
  d.fx = null; d.fy = null;
}

// ======= ZOOM CONTROL =======
svg.call(d3.zoom()
  .scaleExtent([0.3, 4])
  .on("zoom", e => g.attr("transform", e.transform)));
</script>
</body>
</html>

